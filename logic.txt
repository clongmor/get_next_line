# **************************************************************************** #
#                                                                              #
#                                                         :::      ::::::::    #
#    logic.txt                                          :+:      :+:    :+:    #
#                                                     +:+ +:+         +:+      #
#    By: clongmor <marvin@42.fr>                    +#+  +:+       +#+         #
#                                                 +#+#+#+#+#+   +#+            #
#    Created: 2019/06/13 14:48:57 by clongmor          #+#    #+#              #
#    Updated: 2019/06/18 11:42:18 by clongmor         ###   ########.fr        #
#                                                                              #
# **************************************************************************** #

1: create variables: buffer, static storage string, int counting bytes read, temp var for storing during free
2: check for passing null or incorrect input
3: read int input and count bytes read into buffer while read is still valid-> set end of buff = '\0', mark as end of read into buffer.
3a: check if storage string is empty -> if it is, make a new string and fill with nul chars
3b: add the buff read in string to the storage string using strjoin, overwrite the null char.
3c: store into temp var, free memory of storage string, store back in storage string.
3d: check if buff read in a newline char using strchr, if it did, break out of the loop.
4: check if read quit out
5: check if read happened correctly, and finished and the storage string is empty since its all been read into proper storage string supplied
6: otherwise return the secondary function


1: create variable for temp storage during free and len counting to newlien char
2: iterate through the string stored until a newline or and end of file (\0) is found and count.
3: check if the condition was \n-> stores the line in supplied line variable
3a: copy the remainder of the string after the newline into a temp variable.
3b: free the memory from the storage string
3c: put the reamining string back in the storage string
3d: check if the storage string only contains a \0-> then clear it and set it to NULL
4: check if the condition was \0
4a: check if int reading bytes is equal to max amount of bytes possible in buffer-> call 1st function again.
4b: copy in last of storage string to supplied line var
4c: clear storage string variable and set to null.
5: return 1 to indictae it successfully finished reading eveyrthing.

#include "get_next_line.h"
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>

int 		stock ( char ** overflow, char ** line, int * counter )
{
	int 		i;
	char 	* save;

	i = 0 ;
	while  ( ( overflow ) [ i ] )
		if  ( ( * overflow ) [ i ] == ' \ n ' )
		{
			save = memalloc ( ( strlen ( * overflow ) - i ) * sizeof ( char ) ) ;
			if  ( ! save )
				return  ( -1 ) ;
			save = strcpy ( save, & ( ( overflow ) [ i + 1 ] ) ) ;
			* line = strncpy ( * line, * overflow, i ) ;
			( * line ) [ i ++ ] = ' \ 0 ' ;
			free ( * overflow ) ;
			* overflow = save;
			return  ( 1 ) ;
		}
		else
			i ++;
	* counter + = i;
	* line = strncpy ( * line, * overflow, i ) ;
	* line = ( char * ) realloc ( * line, * counter, * counter + BUFF_SIZE + 1 ) ;
	free ( * overflow ) ;
	* overflow = NULL ;
	return  ( 0 ) ;
}

int 		line_split ( char ** overflow, char ** line, int * counter )
{
	int 	i;

	( * line ) [ * counter ] = ' \ 0 ' ;
	i = 0 ;
	while  ( ( * line ) [ i ] )
	{
		if  ( ( * line ) [ i ] == ' \ n ' )
		{
			if  ( ( * line ) [ i + 1 ] )
			{
				* overflow = ( char * ) memalloc ( ( * counter - i ) * sizeof ( char ) ) ;
				if  ( ! * overflow )
					return  ( -1 ) ;
				* overflow = strncpy ( * overflow, ( * line + i + 1 ) , * counter - i ) ;
				( * overflow ) [ * counter - i - 1 ] = ' \ 0 ' ;
			}
			( * line ) [ i ] = ' \ 0 ' ;
			return  ( 1 ) ;
		}
		i ++;
	}
	return  ( 0 ) ;
}

int 		initialization ( const  int fd, char *** line, char *** overflow )
{
	if  ( fd < 0 || fd> 5000 ||! * line || FDS <= 0 || BUFF_SIZE <= 0 )
		return  ( -1 ) ;
	if  ( ! * overflow )
	{
		if  ( ! ( * overflow = ( char ** ) memalloc ( FDS * sizeof ( char *) ) ) )
			return  ( -1 ) ;
	}
	if  ( ! ( ** line = ( char * ) memalloc ( ( BUFF_SIZE + 1 ) * sizeof ( char ) ) ) )
	{
		free ( * overflow ) ;
		return  ( -1 ) ;
	}
	return  ( 0 ) ;
}

int 		get_next_line ( const  int fd, char ** line )
{
	static 	char 	** overflow;
	int 				r;
	int 				counter;
	int 				result;

	counter = 0 ;
	if  ( initialization ( fd, & line, & overflow ) )
		return  ( -1 ) ;
	if  ( overflow [ fd ] && ( result = stock ( & ( overflow [ fd ] ) , line, & counter ) ) )
		return  ( result ) ;
	while  ( ( r = read ( fd, ( * line + counter ), BUFF_SIZE ) ) > 0 && ( counter + = r ) )
		if  ( ( result = line_split ( & ( overflow [ fd ] ) , line, & counter ) ) )
			return  ( result ) ;
		else  if  ( r == BUFF_SIZE )
		{
			* line = ( char * ) realloc ( * line, counter * sizeof ( char ) ,
					( counter + BUFF_SIZE + 1 ) * sizeof ( char ) ) ;
			if  ( ! * line )
				return  ( -1 ) ;
		}
	if  ( r < 0 || ( ( * line ) [ counter ] = ' \ 0 ' ) )
		return  ( -1 ) ;
	return  ( ** line? 1 : 0 ) ;
}

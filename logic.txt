# **************************************************************************** #
#                                                                              #
#                                                         :::      ::::::::    #
#    logic.txt                                          :+:      :+:    :+:    #
#                                                     +:+ +:+         +:+      #
#    By: clongmor <marvin@42.fr>                    +#+  +:+       +#+         #
#                                                 +#+#+#+#+#+   +#+            #
#    Created: 2019/06/13 14:48:57 by clongmor          #+#    #+#              #
#    Updated: 2019/06/13 15:10:55 by clongmor         ###   ########.fr        #
#                                                                              #
# **************************************************************************** #

1: create variables: buffer, static storage string, int counting bytes read, temp var for storing during free
2: check for passing null or incorrect input
3: read int input and count bytes read into buffer while read is still valid-> set end of buff = '\0', mark as end of read into buffer.
3a: check if storage string is empty -> if it is, make a new string and fill with nul chars
3b: add the buff read in string to the storage string using strjoin, overwrite the null char.
3c: store into temp var, free memory of storage string, store back in storage string.
3d: check if buff read in a newline char using strchr, if it did, break out of the loop.
4: check if read quit out
5: check if read happened correctly, and finished and the storage string is empty since its all been read into proper storage string supplied
6: otherwise return the secondary function


1: create variable for temp storage during free and len counting to newlien char
2: iterate through the string stored until a newline or and end of file (\0) is found and count.
3: check if the condition was \n-> stores the line in supplied line variable
3a: copy the remainder of the string after the newline into a temp variable.
3b: free the memory from the storage string
3c: put the reamining string back in the storage string
3d: check if the storage string only contains a \0-> then clear it and set it to NULL
4: check if the condition was \0
4a: check if int reading bytes is equal to max amount of bytes possible in buffer-> call 1st function again.
4b: copy in last of storage string to supplied line var
4c: clear storage string variable and set to null.
5: return 1 to indictae it successfully finished reading eveyrthing.
